<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Escape Route Simulator</title>
    <style>
        :root {
            --wall-color: #555;
            --floor-color: #f5f5f5;
            --exit-color: #4caf50;
            --fire-color: #ff5722;
            --person-color: #2196f3;
            --path-color: #90caf9;
            --visited-color: #e3f2fd;
            --border-color: #ddd;
            --grid-size: 20px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f9f9f9;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #ff5722;
        }

        h1 {
            font-size: 2.2rem;
            color: #ff5722;
            margin-bottom: 10px;
        }

        .description {
            max-width: 700px;
            margin: 0 auto 20px;
            font-size: 1rem;
            color: #777;
            text-align: center;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .controls {
            flex: 1;
            min-width: 300px;
        }

        .simulation {
            flex: 2;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h2 {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input[type="number"], select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            background-color: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
            flex: 1;
            min-width: 120px;
        }

        button:hover {
            background-color: #1976d2;
        }

        button:disabled {
            background-color: #bdbdbd;
            cursor: not-allowed;
        }

        .action-button {
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
            margin-top: 10px;
            font-weight: bold;
        }

        #startBtn {
            background-color: #4caf50;
        }

        #startBtn:hover {
            background-color: #388e3c;
        }

        #resetBtn {
            background-color: #f44336;
        }

        #resetBtn:hover {
            background-color: #d32f2f;
        }

        #pauseBtn {
            background-color: #ff9800;
        }

        #pauseBtn:hover {
            background-color: #f57c00;
        }

        .tool-selected {
            background-color: #673ab7;
        }

        .grid-container {
            position: relative;
            border: 1px solid #ddd;
            overflow: hidden;
            margin-bottom: 20px;
            user-select: none;
            display: inline-block;
        }

        .grid {
            display: grid;
            background-color: var(--floor-color);
        }

        .cell {
            width: var(--grid-size);
            height: var(--grid-size);
            border: 1px solid var(--border-color);
            transition: background-color 0.2s;
        }

        .wall {
            background-color: var(--wall-color);
        }

        .exit {
            background-color: var(--exit-color);
        }

        .fire {
            background-color: var(--fire-color);
            animation: fire-pulse 1s infinite alternate;
        }

        .person {
            background-color: var(--person-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            font-size: 12px;
        }

        .path {
            background-color: var(--path-color);
        }

        .visited {
            background-color: var(--visited-color);
        }

        @keyframes fire-pulse {
            from {
                background-color: #ff5722;
                box-shadow: 0 0 5px #ff5722;
            }
            to {
                background-color: #ff9800;
                box-shadow: 0 0 10px #ff9800;
            }
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border: 1px solid #ddd;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
        }

        .success {
            background-color: #e8f5e9;
            color: #388e3c;
        }

        .danger {
            background-color: #ffebee;
            color: #d32f2f;
        }

        .info {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .stats-panel {
            width: 100%;
            margin-top: 20px;
        }

        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 10px;
        }

        .stat-item {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #777;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .simulation {
                width: 100%;
                overflow-x: auto;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>üî• Fire Escape Route Simulator üèÉ</h1>
        <p class="description">
            Simulate evacuation routes in emergency situations with obstacles, fires, and dynamic path finding.
            Observe how fires spread and affect escape routes in real-time.
        </p>
    </header>

    <div class="container">
        <div class="controls panel">
            <h2>Simulation Controls</h2>
            
            <div class="control-group">
                <label for="gridRows">Grid Rows:</label>
                <input type="number" id="gridRows" min="5" max="30" value="15">
                
                <label for="gridCols">Grid Columns:</label>
                <input type="number" id="gridCols" min="5" max="30" value="20">
                
                <label for="algorithm">Pathfinding Algorithm:</label>
                <select id="algorithm">
                    <option value="bfs">Breadth-First Search (BFS)</option>
                    <option value="astar">A* Algorithm</option>
                </select>
                
                <label for="fireSpreadSpeed">Fire Spread Speed (ms):</label>
                <input type="number" id="fireSpreadSpeed" min="200" max="2000" step="100" value="800">
                
                <label for="peopleCount">Number of People:</label>
                <input type="number" id="peopleCount" min="1" max="10" value="3">
                
                <button id="generateGridBtn" class="action-button">Generate Grid</button>
            </div>
            
            <h2>Drawing Tools</h2>
            <div class="btn-group">
                <button id="wallTool" class="drawing-tool">Wall</button>
                <button id="exitTool" class="drawing-tool">Exit</button>
                <button id="fireTool" class="drawing-tool">Fire</button>
                <button id="personTool" class="drawing-tool">Person</button>
                <button id="eraseTool" class="drawing-tool">Erase</button>
            </div>
            
            <div class="control-group">
                <button id="randomObstaclesBtn">Random Obstacles</button>
                <button id="randomFiresBtn">Random Fires</button>
                <button id="randomPeopleBtn">Random People</button>
                <button id="clearGridBtn">Clear Grid</button>
            </div>
            
            <div class="btn-group">
                <button id="startBtn" class="action-button">Start Simulation</button>
                <button id="pauseBtn" class="action-button" disabled>Pause</button>
                <button id="resetBtn" class="action-button">Reset</button>
            </div>
        </div>

        <div class="simulation panel">
            <h2>Evacuation Simulation</h2>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--wall-color);"></div>
                    <span>Wall</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--exit-color);"></div>
                    <span>Exit</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--fire-color);"></div>
                    <span>Fire</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--person-color); border-radius: 50%;"></div>
                    <span>Person</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--path-color);"></div>
                    <span>Path</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--visited-color);"></div>
                    <span>Visited</span>
                </div>
            </div>
            
            <div id="gridContainer" class="grid-container">
                <div id="grid" class="grid"></div>
            </div>
            
            <div id="status" class="status info">
                Generate a grid and place obstacles, exits, fires, and people to begin.
            </div>
            
            <div class="stats-panel">
                <h2>Simulation Statistics</h2>
                <div class="stats">
                    <div class="stat-item">
                        <div id="escapedCount" class="stat-value">0</div>
                        <div class="stat-label">People Escaped</div>
                    </div>
                    <div class="stat-item">
                        <div id="trappedCount" class="stat-value">0</div>
                        <div class="stat-label">People Trapped</div>
                    </div>
                    <div class="stat-item">
                        <div id="fireCount" class="stat-value">0</div>
                        <div class="stat-label">Fire Cells</div>
                    </div>
                    <div class="stat-item">
                        <div id="timeElapsed" class="stat-value">0s</div>
                        <div class="stat-label">Time Elapsed</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const CELL_TYPES = {
            EMPTY: 'empty',
            WALL: 'wall',
            EXIT: 'exit',
            FIRE: 'fire',
            PERSON: 'person',
            PATH: 'path',
            VISITED: 'visited'
        };

        // DOM Elements
        const gridRowsInput = document.getElementById('gridRows');
        const gridColsInput = document.getElementById('gridCols');
        const algorithmSelect = document.getElementById('algorithm');
        const fireSpreadSpeedInput = document.getElementById('fireSpreadSpeed');
        const peopleCountInput = document.getElementById('peopleCount');
        const generateGridBtn = document.getElementById('generateGridBtn');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const gridContainer = document.getElementById('gridContainer');
        const grid = document.getElementById('grid');
        const statusDisplay = document.getElementById('status');
        const escapedCountDisplay = document.getElementById('escapedCount');
        const trappedCountDisplay = document.getElementById('trappedCount');
        const fireCountDisplay = document.getElementById('fireCount');
        const timeElapsedDisplay = document.getElementById('timeElapsed');
        const randomObstaclesBtn = document.getElementById('randomObstaclesBtn');
        const randomFiresBtn = document.getElementById('randomFiresBtn');
        const randomPeopleBtn = document.getElementById('randomPeopleBtn');
        const clearGridBtn = document.getElementById('clearGridBtn');
        const drawingTools = document.querySelectorAll('.drawing-tool');

        // State variables
        let gridData = [];
        let rows = 15;
        let cols = 20;
        let currentTool = CELL_TYPES.WALL;
        let isDrawing = false;
        let isSimulationRunning = false;
        let isPaused = false;
        let peopleData = [];
        let fireData = [];
        let exitData = [];
        let fireSpreadInterval;
        let pathfindingInterval;
        let simulationTimeInterval;
        let simulationTime = 0;
        let escapedCount = 0;
        let trappedCount = 0;

        // Initialize the page
        window.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            generateGrid();
        });

        // Setup event listeners
        function setupEventListeners() {
            generateGridBtn.addEventListener('click', generateGrid);
            startBtn.addEventListener('click', startSimulation);
            pauseBtn.addEventListener('click', togglePause);
            resetBtn.addEventListener('click', resetSimulation);
            randomObstaclesBtn.addEventListener('click', generateRandomObstacles);
            randomFiresBtn.addEventListener('click', generateRandomFires);
            randomPeopleBtn.addEventListener('click', generateRandomPeople);
            clearGridBtn.addEventListener('click', clearGrid);

            // Setup drawing tools
            drawingTools.forEach(tool => {
                tool.addEventListener('click', () => {
                    drawingTools.forEach(t => t.classList.remove('tool-selected'));
                    tool.classList.add('tool-selected');
                    
                    switch(tool.id) {
                        case 'wallTool': currentTool = CELL_TYPES.WALL; break;
                        case 'exitTool': currentTool = CELL_TYPES.EXIT; break;
                        case 'fireTool': currentTool = CELL_TYPES.FIRE; break;
                        case 'personTool': currentTool = CELL_TYPES.PERSON; break;
                        case 'eraseTool': currentTool = CELL_TYPES.EMPTY; break;
                    }
                });
            });

            // Select wall tool by default
            document.getElementById('wallTool').classList.add('tool-selected');
        }

        // Generate the grid
        function generateGrid() {
            rows = parseInt(gridRowsInput.value) || 15;
            cols = parseInt(gridColsInput.value) || 20;
            
            // Validate input
            if (rows < 5) rows = 5;
            if (rows > 30) rows = 30;
            if (cols < 5) cols = 5;
            if (cols > 30) cols = 30;
            
            gridRowsInput.value = rows;
            gridColsInput.value = cols;
            
            // Clear existing grid
            grid.innerHTML = '';
            
            // Set grid template columns
            grid.style.gridTemplateColumns = `repeat(${cols}, var(--grid-size))`;
            
            // Initialize grid data
            gridData = Array(rows).fill().map(() => Array(cols).fill(CELL_TYPES.EMPTY));
            peopleData = [];
            fireData = [];
            exitData = [];
            
            // Create grid cells
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    // Mouse events for drawing
                    cell.addEventListener('mousedown', (e) => {
                        isDrawing = true;
                        setCellType(i, j, currentTool);
                        e.preventDefault(); // Prevent drag selection
                    });
                    
                    cell.addEventListener('mouseenter', () => {
                        if (isDrawing) {
                            setCellType(i, j, currentTool);
                        }
                    });
                    
                    grid.appendChild(cell);
                }
            }
            
            // Add global mouse up event
            document.addEventListener('mouseup', () => {
                isDrawing = false;
            });
            
            // Add border walls
            addBorderWalls();
            
            updateStatus('Grid generated. Draw walls, exits, fires, and people, then start the simulation.');
            resetStats();
        }

        // Add walls around the border of the grid
        function addBorderWalls() {
            for (let i = 0; i < rows; i++) {
                setCellType(i, 0, CELL_TYPES.WALL);
                setCellType(i, cols - 1, CELL_TYPES.WALL);
            }
            
            for (let j = 0; j < cols; j++) {
                setCellType(0, j, CELL_TYPES.WALL);
                setCellType(rows - 1, j, CELL_TYPES.WALL);
            }
        }

        // Set cell type and update visual
        function setCellType(row, col, type) {
            // Skip if out of bounds
            if (row < 0 || row >= rows || col < 0 || col >= cols) return;
            
            const cellElement = getCellElement(row, col);
            if (!cellElement) return;
            
            // Clear existing classes
            cellElement.classList.remove('wall', 'exit', 'fire', 'person', 'path', 'visited');
            
            // Handle special case for person
            if (type === CELL_TYPES.PERSON) {
                // Check if there's already a person or obstacle
                if (gridData[row][col] === CELL_TYPES.WALL || gridData[row][col] === CELL_TYPES.FIRE) {
                    return;
                }
                
                // Limit number of people
                const maxPeople = parseInt(peopleCountInput.value) || 3;
                if (peopleData.length >= maxPeople) {
                    // Remove the oldest person
                    const oldestPerson = peopleData.shift();
                    const oldCell = getCellElement(oldestPerson.row, oldestPerson.col);
                    if (oldCell) {
                        oldCell.classList.remove('person');
                        oldCell.textContent = '';
                    }
                    gridData[oldestPerson.row][oldestPerson.col] = CELL_TYPES.EMPTY;
                }
                
                // Add new person
                peopleData.push({ row, col, path: [], status: 'waiting' });
                cellElement.textContent = peopleData.length;
            } else if (type === CELL_TYPES.EXIT) {
                // Handle exit
                exitData.push({ row, col });
            } else if (type === CELL_TYPES.FIRE) {
                // Handle fire
                fireData.push({ row, col });
            } else if (type === CELL_TYPES.EMPTY) {
                // Handle erasing - check if we're removing a person
                if (gridData[row][col] === CELL_TYPES.PERSON) {
                    const personIndex = peopleData.findIndex(p => p.row === row && p.col === col);
                    if (personIndex !== -1) {
                        peopleData.splice(personIndex, 1);
                        cellElement.textContent = '';
                        
                        // Renumber remaining people
                        peopleData.forEach((person, index) => {
                            const personCell = getCellElement(person.row, person.col);
                            if (personCell) {
                                personCell.textContent = index + 1;
                            }
                        });
                    }
                } else if (gridData[row][col] === CELL_TYPES.EXIT) {
                    // Remove from exitData
                    const exitIndex = exitData.findIndex(e => e.row === row && e.col === col);
                    if (exitIndex !== -1) {
                        exitData.splice(exitIndex, 1);
                    }
                } else if (gridData[row][col] === CELL_TYPES.FIRE) {
                    // Remove from fireData
                    const fireIndex = fireData.findIndex(f => f.row === row && f.col === col);
                    if (fireIndex !== -1) {
                        fireData.splice(fireIndex, 1);
                    }
                }
                
                cellElement.textContent = '';
            }
            
            // Update gridData
            gridData[row][col] = type;
            
            // Add appropriate class
            if (type !== CELL_TYPES.EMPTY) {
                cellElement.classList.add(type);
            }
            
            // Update statistics
            updateFireCount();
        }

        // Get cell element from grid
        function getCellElement(row, col) {
            return document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
        }

        // Generate random obstacles
        function generateRandomObstacles() {
            // Clear existing walls (except border)
            for (let i = 1; i < rows - 1; i++) {
                for (let j = 1; j < cols - 1; j++) {
                    if (gridData[i][j] === CELL_TYPES.WALL) {
                        setCellType(i, j, CELL_TYPES.EMPTY);
                    }
                }
            }
            
            // Add random walls
            const obstacleCount = Math.floor((rows * cols) * 0.2); // About 20% of cells
            for (let i = 0; i < obstacleCount; i++) {
                const row = Math.floor(Math.random() * (rows - 2)) + 1;
                const col = Math.floor(Math.random() * (cols - 2)) + 1;
                
                // Don't place on existing content
                if (gridData[row][col] === CELL_TYPES.EMPTY) {
                    setCellType(row, col, CELL_TYPES.WALL);
                }
            }
        }

        // Generate random fires
        function generateRandomFires() {
            // Clear existing fires
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (gridData[i][j] === CELL_TYPES.FIRE) {
                        setCellType(i, j, CELL_TYPES.EMPTY);
                    }
                }
            }
            
            fireData = [];
            
            // Add random fires
            const fireCount = Math.floor((rows * cols) * 0.05); // About 5% of cells
            for (let i = 0; i < fireCount; i++) {
                const row = Math.floor(Math.random() * (rows - 2)) + 1;
                const col = Math.floor(Math.random() * (cols - 2)) + 1;
                
                // Don't place on existing content
                if (gridData[row][col] === CELL_TYPES.EMPTY) {
                    setCellType(row, col, CELL_TYPES.FIRE);
                }
            }
            
            updateFireCount();
        }

        // Generate random people
        function generateRandomPeople() {
            // Clear existing people
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (gridData[i][j] === CELL_TYPES.PERSON) {
                        setCellType(i, j, CELL_TYPES.EMPTY);
                    }
                }
            }
            
            peopleData = [];
            
            // Add random people
            const peopleCount = parseInt(peopleCountInput.value) || 3;
            for (let i = 0; i < peopleCount; i++) {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const row = Math.floor(Math.random() * (rows - 2)) + 1;
                    const col = Math.floor(Math.random() * (cols - 2)) + 1;
                    
                    // Don't place on existing content
                    if (gridData[row][col] === CELL_TYPES.EMPTY) {
                        setCellType(row, col, CELL_TYPES.PERSON);
                        placed = true;
                    }
                    
                    attempts++;
                }
            }
        }

        // Clear the grid (except border walls)
        function clearGrid() {
            for (let i = 1; i < rows - 1; i++) {
                for (let j = 1; j < cols - 1; j++) {
                    setCellType(i, j, CELL_TYPES.EMPTY);
                }
            }
            
            peopleData = [];
            fireData = [];
            exitData = [];
            resetStats();
            updateStatus('Grid cleared. Draw walls, exits, fires, and people.');
        }

        // Start the simulation
        function startSimulation() {
            // Check if we have at least one exit and one person
            if (exitData.length === 0) {
                alert('Please add at least one exit!');
                return;
            }
            
            if (peopleData.length === 0) {
                alert('Please add at least one person!');
                return;
            }
            
            // Reset any previous simulation
            clearPathVisualizations();
            
            // Set initial state
            isSimulationRunning = true;
            isPaused = false;
            simulationTime = 0;
            escapedCount = 0;
            trappedCount = 0;
            updateStats();
            
            // Reset people data
            peopleData.forEach(person => {
                person.path = [];
                person.status = 'waiting';
                person.visited = new Set();
            });
            
            // Update UI
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            pauseBtn.textContent = 'Pause';
            
            updateStatus('Simulation started. Finding escape routes...');
            
            // Start fire spread
            startFireSpread();
            
            // Start pathfinding for people
            startPathfinding();
            
            // Start timer
            simulationTimeInterval = setInterval(() => {
                if (!isPaused) {
                    simulationTime += 0.1;
                    timeElapsedDisplay.textContent = simulationTime.toFixed(1) + 's';
                }
            }, 100);
        }

        // Toggle pause state
        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
            
            updateStatus(isPaused ? 'Simulation paused.' : 'Simulation resumed.');
        }

        // Reset the simulation
        function resetSimulation() {
            // Stop intervals
            if (fireSpreadInterval) clearInterval(fireSpreadInterval);
            if (pathfindingInterval) clearInterval(pathfindingInterval);
            if (simulationTimeInterval) clearInterval(simulationTimeInterval);
            
            isSimulationRunning = false;
            isPaused = false;
            
            // Clear paths and visited cells
            clearPathVisualizations();
            
            // Reset people locations
            peopleData.forEach(person => {
                // Remove from current position if they moved
                if (gridData[person.row][person.col] === CELL_TYPES.PATH) {
                    setCellType(person.row, person.col, CELL_TYPES.EMPTY);
                }
                
                // Reset to original position
                const originalCell = getCellElement(person.originalRow || person.row, person.originalCol || person.col);
                if (originalCell) {
                    setCellType(person.originalRow || person.row, person.originalCol || person.col, CELL_TYPES.PERSON);
                }
                
                // Reset status
                person.path = [];
                person.status = 'waiting';
                person.visited = new Set();
            });
            
            // Reset UI
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            
            resetStats();
            updateStatus('Simulation reset. Ready to start again.');
        }

        // Clear path visualizations
        function clearPathVisualizations() {
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (gridData[i][j] === CELL_TYPES.PATH || gridData[i][j] === CELL_TYPES.VISITED) {
                        setCellType(i, j, CELL_TYPES.EMPTY);
                    }
                }
            }
        }

        // Start fire spread simulation
        function startFireSpread() {
            const fireSpreadSpeed = parseInt(fireSpreadSpeedInput.value) || 800;
            
            if (fireSpreadInterval) clearInterval(fireSpreadInterval);
            
            fireSpreadInterval = setInterval(() => {
                if (!isPaused && isSimulationRunning) {
                    spreadFire();
                }
            }, fireSpreadSpeed);
        }

        // Spread fire to neighboring cells
        function spreadFire() {
            // Create a copy of fire data to avoid modifying while iterating
            const newFireCells = [];
            
            fireData.forEach(fire => {
                const neighbors = getNeighbors(fire.row, fire.col);
                
                neighbors.forEach(neighbor => {
                    // Only spread to empty cells, paths, or visited cells
                    if (
                        (gridData[neighbor.row][neighbor.col] === CELL_TYPES.EMPTY ||
                         gridData[neighbor.row][neighbor.col] === CELL_TYPES.PATH ||
                         gridData[neighbor.row][neighbor.col] === CELL_TYPES.VISITED) &&
                        Math.random() < 0.3 // 30% chance to spread to each neighbor
                    ) {
                        newFireCells.push({ row: neighbor.row, col: neighbor.col });
                    }
                });
            });
            
            // Add new fire cells
            newFireCells.forEach(cell => {
                setCellType(cell.row, cell.col, CELL_TYPES.FIRE);
                fireData.push(cell);
            });
            
            // Update fire count
            updateFireCount();
            
            // Check if fire caught any people
            checkFireCollisions();
        }

        // Check if fire has caught any people
        function checkFireCollisions() {
            peopleData.forEach(person => {
                if (person.status === 'moving' || person.status === 'waiting') {
                    // Check if current position is on fire
                    if (gridData[person.row][person.col] === CELL_TYPES.FIRE) {
                        person.status = 'trapped';
                        trappedCount++;
                        updateStats();
                        
                        // Update visual
                        const cell = getCellElement(person.row, person.col);
                        if (cell) {
                            cell.style.backgroundColor = '#ff9800';
                            cell.style.border = '2px solid red';
                        }
                    }
                }
            });
            
            // Check if all people are either trapped or escaped
            checkSimulationEnd();
        }

        // Start pathfinding for people
        function startPathfinding() {
            if (pathfindingInterval) clearInterval(pathfindingInterval);
            
            // Initialize people with original positions
            peopleData.forEach(person => {
                person.originalRow = person.row;
                person.originalCol = person.col;
                person.visited = new Set();
            });
            
            // Calculate initial paths
            calculateAllPaths();
            
            // Start moving people
            pathfindingInterval = setInterval(() => {
                if (!isPaused && isSimulationRunning) {
                    movePeople();
                    // Recalculate paths every few steps to account for fire spread
                    if (simulationTime % 2 < 0.1) { // Approximately every 2 seconds
                        calculateAllPaths();
                    }
                }
            }, 300);
        }

        // Calculate paths for all people
        function calculateAllPaths() {
            const algorithm = algorithmSelect.value;
            
            peopleData.forEach(person => {
                if (person.status === 'waiting' || person.status === 'moving') {
                    // Clear existing path
                    clearPersonPath(person);
                    
                    // Calculate new path
                    if (algorithm === 'bfs') {
                        person.path = findPathBFS(person);
                    } else {
                        person.path = findPathAStar(person);
                    }
                    
                    // If no path found and not already trapped, mark as trapped
                    if (person.path.length === 0 && person.status !== 'trapped') {
                        person.status = 'trapped';
                        trappedCount++;
                        updateStats();
                        
                        // Update visual
                        const cell = getCellElement(person.row, person.col);
                        if (cell) {
                            cell.style.backgroundColor = '#ff9800';
                            cell.style.border = '2px solid red';
                        }
                    } else if (person.path.length > 0) {
                        person.status = 'moving';
                    }
                }
            });
        }

        // Clear person's path from visualization
        function clearPersonPath(person) {
            if (person.path) {
                person.path.forEach(pos => {
                    if (
                        gridData[pos.row][pos.col] === CELL_TYPES.PATH ||
                        gridData[pos.row][pos.col] === CELL_TYPES.VISITED
                    ) {
                        setCellType(pos.row, pos.col, CELL_TYPES.EMPTY);
                    }
                });
            }
        }

        // Find path using BFS
        function findPathBFS(person) {
            if (person.status === 'trapped' || person.status === 'escaped') {
                return [];
            }
            
            // Queue for BFS
            const queue = [{ row: person.row, col: person.col, path: [] }];
            const visited = new Set();
            visited.add(`${person.row},${person.col}`);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                // Check if this is an exit
                if (isExit(current.row, current.col)) {
                    return current.path;
                }
                
                // Get neighbors
                const neighbors = getNeighbors(current.row, current.col);
                
                for (const neighbor of neighbors) {
                    const key = `${neighbor.row},${neighbor.col}`;
                    
                    // Skip walls, fire, and visited cells
                    if (
                        gridData[neighbor.row][neighbor.col] !== CELL_TYPES.WALL &&
                        gridData[neighbor.row][neighbor.col] !== CELL_TYPES.FIRE &&
                        !visited.has(key)
                    ) {
                        visited.add(key);
                        
                        // Create new path
                        const newPath = [...current.path, { row: neighbor.row, col: neighbor.col }];
                        queue.push({ row: neighbor.row, col: neighbor.col, path: newPath });
                        
                        // Visualize visited cells
                        if (
                            gridData[neighbor.row][neighbor.col] !== CELL_TYPES.EXIT &&
                            gridData[neighbor.row][neighbor.col] !== CELL_TYPES.PERSON
                        ) {
                            const cell = getCellElement(neighbor.row, neighbor.col);
                            if (cell) {
                                setCellType(neighbor.row, neighbor.col, CELL_TYPES.VISITED);
                            }
                        }
                    }
                }
            }
            
            // No path found
            return [];
        }

        // Find path using A*
        function findPathAStar(person) {
            if (person.status === 'trapped' || person.status === 'escaped') {
                return [];
            }
            
            // Find nearest exit
            const nearest = findNearestExit(person.row, person.col);
            if (!nearest) return []; // No exits available
            
            // Priority queue for A*
            const openSet = [{ 
                row: person.row, 
                col: person.col, 
                g: 0, // Cost from start
                h: manhattan(person.row, person.col, nearest.row, nearest.col), // Heuristic
                path: [] 
            }];
            
            const closedSet = new Set();
            const gScore = {}; // Best known cost from start to each position
            gScore[`${person.row},${person.col}`] = 0;
            
            while (openSet.length > 0) {
                // Sort by f = g + h (total estimated cost)
                openSet.sort((a, b) => (a.g + a.h) - (b.g + b.h));
                const current = openSet.shift();
                
                // Check if this is an exit
                if (isExit(current.row, current.col)) {
                    return current.path;
                }
                
                const currentKey = `${current.row},${current.col}`;
                closedSet.add(currentKey);
                
                // Get neighbors
                const neighbors = getNeighbors(current.row, current.col);
                
                for (const neighbor of neighbors) {
                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                    
                    // Skip walls, fire, and closed cells
                    if (
                        gridData[neighbor.row][neighbor.col] !== CELL_TYPES.WALL &&
                        gridData[neighbor.row][neighbor.col] !== CELL_TYPES.FIRE &&
                        !closedSet.has(neighborKey)
                    ) {
                        // Calculate tentative g score
                        const tentativeG = current.g + 1;
                        
                        // Check if this is a better path
                        if (!gScore[neighborKey] || tentativeG < gScore[neighborKey]) {
                            // Update scores
                            gScore[neighborKey] = tentativeG;
                            
                            // Create new path
                            const newPath = [...current.path, { row: neighbor.row, col: neighbor.col }];
                            
                            // Add to open set if not already there
                            const existingIndex = openSet.findIndex(item => item.row === neighbor.row && item.col === neighbor.col);
                            
                            if (existingIndex === -1) {
                                openSet.push({
                                    row: neighbor.row,
                                    col: neighbor.col,
                                    g: tentativeG,
                                    h: manhattan(neighbor.row, neighbor.col, nearest.row, nearest.col),
                                    path: newPath
                                });
                                
                                // Visualize visited cells
                                if (
                                    gridData[neighbor.row][neighbor.col] !== CELL_TYPES.EXIT &&
                                    gridData[neighbor.row][neighbor.col] !== CELL_TYPES.PERSON
                                ) {
                                    setCellType(neighbor.row, neighbor.col, CELL_TYPES.VISITED);
                                }
                            } else {
                                // Update existing node in open set
                                openSet[existingIndex].g = tentativeG;
                                openSet[existingIndex].path = newPath;
                            }
                        }
                    }
                }
            }
            
            // No path found
            return [];
        }
        
        // Find nearest exit
        function findNearestExit(row, col) {
            if (exitData.length === 0) return null;
            
            let nearest = exitData[0];
            let minDistance = manhattan(row, col, nearest.row, nearest.col);
            
            exitData.forEach(exit => {
                const distance = manhattan(row, col, exit.row, exit.col);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = exit;
                }
            });
            
            return nearest;
        }
        
        // Manhattan distance (for A* heuristic)
        function manhattan(row1, col1, row2, col2) {
            return Math.abs(row1 - row2) + Math.abs(col1 - col2);
        }

        // Check if position is an exit
        function isExit(row, col) {
            return exitData.some(exit => exit.row === row && exit.col === col);
        }

        // Get adjacent neighbors (4-way)
        function getNeighbors(row, col) {
            const directions = [
                { row: -1, col: 0 }, // Up
                { row: 1, col: 0 },  // Down
                { row: 0, col: -1 }, // Left
                { row: 0, col: 1 }   // Right
            ];
            
            return directions
                .map(dir => ({ row: row + dir.row, col: col + dir.col }))
                .filter(pos => pos.row >= 0 && pos.row < rows && pos.col >= 0 && pos.col < cols);
        }

        // Move people along their paths
        function movePeople() {
            peopleData.forEach(person => {
                if (person.status === 'moving' && person.path.length > 0) {
                    // Get next position
                    const nextPos = person.path.shift();
                    
                    // Check if next position is on fire
                    if (gridData[nextPos.row][nextPos.col] === CELL_TYPES.FIRE) {
                        person.status = 'trapped';
                        trappedCount++;
                        updateStats();
                        
                        // Update visual
                        const cell = getCellElement(person.row, person.col);
                        if (cell) {
                            cell.style.backgroundColor = '#ff9800';
                            cell.style.border = '2px solid red';
                        }
                        
                        return;
                    }
                    
                    // Move person
                    const oldCell = getCellElement(person.row, person.col);
                    if (oldCell) {
                        // If not on exit, mark as path
                        if (!isExit(person.row, person.col)) {
                            setCellType(person.row, person.col, CELL_TYPES.PATH);
                        }
                    }
                    
                    // Update position
                    person.row = nextPos.row;
                    person.col = nextPos.col;
                    
                    // Check if reached exit
                    if (isExit(person.row, person.col)) {
                        person.status = 'escaped';
                        escapedCount++;
                        updateStats();
                        
                        // Update visual
                        const cell = getCellElement(person.row, person.col);
                        if (cell) {
                            cell.classList.add('person');
                            cell.textContent = 'üëç';
                        }
                    } else {
                        // Update visual
                        setCellType(person.row, person.col, CELL_TYPES.PERSON);
                    }
                    
                    // Visualize path
                    person.path.forEach(pathPos => {
                        const pathCell = getCellElement(pathPos.row, pathPos.col);
                        if (
                            pathCell && 
                            gridData[pathPos.row][pathPos.col] !== CELL_TYPES.EXIT &&
                            gridData[pathPos.row][pathPos.col] !== CELL_TYPES.FIRE
                        ) {
                            setCellType(pathPos.row, pathPos.col, CELL_TYPES.PATH);
                        }
                    });
                }
            });
            
            // Check if simulation is complete
            checkSimulationEnd();
        }

        // Check if simulation should end
        function checkSimulationEnd() {
            const totalPeople = peopleData.length;
            const resolvedPeople = escapedCount + trappedCount;
            
            if (resolvedPeople === totalPeople && totalPeople > 0) {
                // Stop simulation
                if (fireSpreadInterval) clearInterval(fireSpreadInterval);
                if (pathfindingInterval) clearInterval(pathfindingInterval);
                
                isSimulationRunning = false;
                
                // Update status
                if (escapedCount === totalPeople) {
                    updateStatus('All people escaped successfully! üéâ', 'success');
                } else if (trappedCount === totalPeople) {
                    updateStatus('All people were trapped! üò¢', 'danger');
                } else {
                    updateStatus(`Simulation ended. ${escapedCount} escaped, ${trappedCount} trapped.`, 'info');
                }
                
                // Enable restart
                startBtn.disabled = false;
                pauseBtn.disabled = true;
            }
        }

        // Update status display
        function updateStatus(message, type = 'info') {
            statusDisplay.textContent = message;
            statusDisplay.className = `status ${type}`;
        }

        // Update statistics
        function updateStats() {
            escapedCountDisplay.textContent = escapedCount;
            trappedCountDisplay.textContent = trappedCount;
        }

        // Update fire count
        function updateFireCount() {
            const count = fireData.length;
            fireCountDisplay.textContent = count;
        }

        // Reset statistics
        function resetStats() {
            simulationTime = 0;
            escapedCount = 0;
            trappedCount = 0;
            timeElapsedDisplay.textContent = '0s';
            escapedCountDisplay.textContent = '0';
            trappedCountDisplay.textContent = '0';
            updateFireCount();
        }
    </script>
</body>
</html>